package main

import (
	"context"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	influx "github.com/influxdata/influxdb-client-go"
	httpstat "github.com/tcnksm/go-httpstat"
)

type result struct {
	DNSLookup        float64
	TCPConnection    float64
	TLSHandshake     float64
	ServerProcessing float64
	ContentTransfer  float64
	Total            float64
	Availability     int
	cdn              string
	workflow         string
	contentType      string
	Headers          string
	Error            error
}

type Config struct {
	NumUsers       int    `json:"num_users"`
	Debug          bool   `json:"debug"`
	UseInfluxDB    bool   `json:"use_influx_db"`
	InfluxDBUrl    string `json:"influx_db_uri"`
	InfluxDBApiKey string `json:"influx_db_api_key"`
	InfluxDBOrg    string `json:"influx_db_org"`
	InfluxDBBucket string `json:"influx_db_bucket"`
	Resources      []struct {
		URL      string `json:"url"`
		CDN      string `json:"cdn"`
		Workflow string `json:"workflow"`
	} `json:"resources"`
}

func writePoint(result result, influxUrl string, org string, bucket string, key string) error {
	client := influx.NewClient(influxUrl, key)
	writeAPI := client.WriteAPIBlocking(org, bucket)
	defer client.Close()

	// DNS Lookup   TCP Connection   TLS Handshake   Server Processing   Content Transfer Total
	point := influx.NewPointWithMeasurement("stats").
		AddTag("cdn", result.cdn).
		AddTag("workflow", result.workflow).
		AddTag("contenttype", result.contentType).
		AddField("dnslookup", result.DNSLookup).
		AddField("tcpconnection", result.TCPConnection).
		AddField("tlshandshake", result.TLSHandshake).
		AddField("serverprocessing", result.ServerProcessing).
		AddField("contenttransfer", result.ContentTransfer).
		AddField("total", result.Total).
		AddField("availability", result.Availability).
		AddField("headers", result.Headers).
		AddField("error", result.Error).
		SetTime(time.Now().UTC())

	err := writeAPI.WritePoint(context.Background(), point)
	if err != nil {
		return err
	}

	return nil
}

func getPort(url string) string {
	if strings.Contains(url, "https://") {
		return ":443"
	}
	return ":80"
}

func parseConfig(filePath string) (Config, error) {
	var config Config

	file, err := os.Open(filePath)
	if err != nil {
		return config, err
	}
	defer file.Close()

	decoder := json.NewDecoder(file)
	err = decoder.Decode(&config)
	if err != nil {
		return config, err
	}

	return config, nil
}

func checkResource(url string, cdn string, workflow string) result {

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return result{Error: err}
	}
	req.Header.Add("User-Agent", "Akamai Lyra/1.2;  Performance Metrics Agent")

	var hres httpstat.Result
	ctx := httpstat.WithHTTPStat(req.Context(), &hres)
	req = req.WithContext(ctx)

	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{
		Transport: tr,
		Timeout:   0,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	res, err := client.Do(req)
	if err != nil {
		return result{Error: err}
	}

	if _, err := io.Copy(io.Discard, res.Body); err != nil {
		return result{Error: err}
	}
	res.Body.Close()

	availability := res.StatusCode
	contenttype := res.Header.Get("content-type")

	headerBytes, err := json.Marshal(res.Header)
	if err != nil {
		return result{Error: err}
	}
	headers := string(headerBytes)

	return result{
		DNSLookup:        float64(hres.DNSLookup / time.Millisecond),
		TCPConnection:    float64(hres.TCPConnection / time.Millisecond),
		TLSHandshake:     float64(hres.TLSHandshake / time.Millisecond),
		ServerProcessing: float64(hres.ServerProcessing / time.Millisecond),
		ContentTransfer:  float64(hres.ContentTransfer(time.Now()) / time.Millisecond),
		Total:            float64(hres.Total(time.Now())),
		Availability:     availability,
		cdn:              cdn,
		workflow:         workflow,
		contentType:      contenttype,
		Headers:          headers,
	}
}

func main() {
	config, err := parseConfig("config.json")
	// Accept user input for the number of virtual users
	numUsers := config.NumUsers
	debug := config.Debug
	resources := config.Resources
	useInfluxDB := config.UseInfluxDB
	influxDBUrl := config.InfluxDBUrl
	influxDBApiKey := config.InfluxDBApiKey
	influxDBOrg := config.InfluxDBOrg
	InfluxDBBucket := config.InfluxDBBucket

	if err != nil {
		log.Fatal(err)
	}

	results := make(chan result)

	for i := 0; i < numUsers; i++ {
		start := time.Now()
		for j := 0; j < len(resources); j++ {
			go func(url string, cdn string, workflow string) {
				results <- checkResource(url, cdn, workflow)
			}(resources[j].URL, resources[j].CDN, resources[j].Workflow)
		}

		for j := 0; j < len(resources); j++ {
			r := <-results

			// DNS Lookup   TCP Connection   TLS Handshake   Server Processing   Content Transfer Total
			if debug {
				resultJSON, err := json.Marshal(r)
				if err != nil {
					fmt.Println("In Debug: Error marshaling resultJSON:", err)
					return
				}
				fmt.Println(string(resultJSON))
			}

			r.Total = float64(time.Since(start).Milliseconds())

			if useInfluxDB {
				err := writePoint(r, influxDBUrl, influxDBOrg, InfluxDBBucket, influxDBApiKey)

				if err != nil {
					fmt.Printf("Error writing point: %v\n", err)
				}
			}

		}
	}
}
